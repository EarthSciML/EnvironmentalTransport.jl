var documenterSearchIndex = {"docs":
[{"location":"puff/#Air-Pollution-\"Puff\"-Model-Example","page":"Puff Model","title":"Air Pollution \"Puff\" Model Example","text":"using EarthSciMLBase, EarthSciData, EnvironmentalTransport\nusing ModelingToolkit\nusing ModelingToolkit: t\nusing DynamicQuantities\nusing DifferentialEquations\nusing Plots\nusing Dates\n\nfirestart = DateTime(2021, 10, 1)\nfirelength = 15 * 24 * 3600 # Seconds\nsimulationlength = 20 # Days\nfirelon = deg2rad(-97)\nfirelat = deg2rad(40)\nfireradius = deg2rad(0.05) # Degrees\nsamplerate = 3600.0 # Seconds\nsamples_per_time = 1 # Samples per each emission time\nfireheight = 2.0 # Vertical level (Allowing this to be automatically calculated is a work in progress).\nemis_rate = 1.0 # kg/s, fire emission rate\n\nsim_end = firestart + Day(simulationlength)\n\ndomain = DomainInfo(\n    firestart, sim_end;\n    lonrange = deg2rad(-115):deg2rad(1.25):deg2rad(-68.75),\n    latrange = deg2rad(25):deg2rad(1):deg2rad(53.7),\n    levrange = 1:72\n)\n\ngeosfp = GEOSFP(\"4x5\", domain; stream = false)\n\npuff = Puff(domain)\n\nmodel = couple(puff, geosfp)\nconst sys = convert(System, model)\nu0 = ModelingToolkit.get_defaults(sys)\ntspan = EarthSciMLBase.get_tspan(domain)\nprob=ODEProblem(sys, u0, tspan)\nsol = solve(prob, Tsit5()) # Solve once to make sure data is loaded.\n\nfunction prob_func(prob, i, repeat)\n    r = rand() * fireradius\n    Î¸ = rand() * 2Ï€\n    u0 = [\n        sys.Puffâ‚Šlon => firelon + r * cos(Î¸),\n        sys.Puffâ‚Šlat => firelat + r * sin(Î¸),\n        sys.Puffâ‚Šlev => fireheight\n    ]\n    ts = (tspan[1] + floor(i / samples_per_time) * samplerate, tspan[2])\n    remake(prob, u0 = u0, tspan = ts)\nend\neprob = EnsembleProblem(prob, prob_func = prob_func, safetycopy = false)\nesol = solve(eprob, Tsit5(); trajectories = ceil(firelength/samplerate*samples_per_time))\n\nvars = [sys.Puffâ‚Šlon, sys.Puffâ‚Šlat, sys.Puffâ‚Šlev]\nvaridxs = ModelingToolkit.variable_index.((sys,), vars)\nranges = [(Inf, -Inf), (Inf, -Inf), (Inf, -Inf)]\nfor sol in esol\n    for (i, var) in enumerate(vars)\n        rng = (minimum(sol[var]), maximum(sol[var]))\n        ranges[i] = (min(ranges[i][1], rng[1]),\n            max(ranges[i][2], rng[2]))\n    end\nend\n\nt_ref = get_tref(domain)\nanim = @animate for dt in datetime2unix(firestart):samplerate:datetime2unix(sim_end)\n    t = dt - t_ref\n    p = plot(\n        xlim = rad2deg.(ranges[1]), ylim = rad2deg.(ranges[2]), zlim = ranges[3],\n        title = \"Time: $(unix2datetime(t + t_ref))\",\n        xlabel = \"Longitude (deg)\", ylabel = \"Latitude (deg)\",\n        zlabel = \"Vertical Level\"\n    )\n    for sol in esol\n        if t < sol.t[1] || t > sol.t[end]\n            continue\n        end\n        lon, lat, lev = sol(t)[varidxs[1]], sol(t)[varidxs[2]], sol(t)[varidxs[3]]\n        color = lev < 2 ? :red : :black\n        scatter!(p,\n            [rad2deg(sol(t)[varidxs[1]])], [rad2deg(sol(t)[varidxs[2]])], [sol(t)[varidxs[3]]],\n            label = :none, markercolor = color, markerstrokecolor = color, markersize = 1.5\n        )\n    end\nend\ngif(anim, fps = 15)","category":"section"},{"location":"benchmarks/#Redirecting...","page":"ðŸ”— Benchmarks","title":"Redirecting...","text":"<html>\n<head>\n    <meta http-equiv=\"refresh\" content=\"0; url=https://transport.earthsci.dev/benchmarks/\" />\n</head>\n<body>\n    <p>If you are not redirected automatically, follow this <a href=\"https://transport.earthsci.dev/benchmarks/\">link</a>.</p>\n</body>\n</html>","category":"section"},{"location":"api/#API-Index","page":"API","title":"API Index","text":"","category":"section"},{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/#EnvironmentalTransport.AdvectionOperator","page":"API","title":"EnvironmentalTransport.AdvectionOperator","text":"Create an EarthSciMLBase.Operator that performs advection. Advection is performed using the given stencil operator (e.g. l94_stencil or ppm_stencil). p is an optional parameter set to be used by the stencil operator. bc_type is the boundary condition type, e.g. ZeroGradBC().\n\nWind field data will be added in automatically if available. Currently the only valid source of wind data is EarthSciData.GEOSFP.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.BCArray","page":"API","title":"EnvironmentalTransport.BCArray","text":"An array with external indexing implemented for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ConstantBC","page":"API","title":"EnvironmentalTransport.ConstantBC","text":"Constant boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ConstantBCArray","page":"API","title":"EnvironmentalTransport.ConstantBCArray","text":"An array with zero constant boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.PBLMixingCallback","page":"API","title":"EnvironmentalTransport.PBLMixingCallback","text":"PBLMixingCallback <: EarthSciMLBase.Operator\n\nA callback that applies planetary boundary layer (PBL) mixing to tracer fields at periodic intervals. PBL mixing is a discrete process that redistributes tracers vertically within each grid column.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.SpeciesConstantBC","page":"API","title":"EnvironmentalTransport.SpeciesConstantBC","text":"Species-specific constant boundary conditions. Takes a dictionary mapping species names/indices to boundary values and a default value.\n\nExamples:\n\nSpeciesConstantBC(Dict(\"O3\" => 40.0), 0.0) sets O3 to 40.0 and others to 0.0\nSpeciesConstantBC(Dict(1 => 40.0), 0.0) sets species 1 to 40.0 and others to 0.0\nSpeciesConstantBC(Dict(\"O3\" => 40.0, \"NO2\" => 10.0), 0.0) sets multiple species\n\nNote: When using species names, they will be resolved to indices when the boundary condition is applied to a system with known species variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.SpeciesConstantBCArray","page":"API","title":"EnvironmentalTransport.SpeciesConstantBCArray","text":"An array with species-specific constant boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ZeroGradBC","page":"API","title":"EnvironmentalTransport.ZeroGradBC","text":"Zero gradient boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ZeroGradBCArray","page":"API","title":"EnvironmentalTransport.ZeroGradBCArray","text":"An array with zero gradient boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.init_callback-Tuple{PBLMixingCallback, EarthSciMLBase.CoupledSystem, Any, Any, EarthSciMLBase.DomainInfo, Any}","page":"API","title":"EarthSciMLBase.init_callback","text":"EarthSciMLBase.init_callback(cb::PBLMixingCallback, csys::CoupledSystem, sys_mtk, coord_args, domain::DomainInfo, alg)\n\nInitialize the PBL mixing callback.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.GaussianPGB-Tuple{}","page":"API","title":"EnvironmentalTransport.GaussianPGB","text":"GaussianPGB()\n\nReturn a ModelingToolkit.System implementing a classic Gaussian plume dispersion model, parameterized with Pasquill-Gifford-Briggs dispersion coefficients, following the formulations described in EPA guidance 402-R-00-004 Â§12.1.6 (https://19january2017snapshot.epa.gov/sites/production/files/2015-05/documents/402-r-00-004.pdf) and the MMGRMA document, Table 6-7 (https://www.epa.gov/sites/default/files/2020-10/documents/mmgrma_0.pdf). Good for: quasi-steady (piecewise-steady) applications where emissions and meteorology can be treated steady over each model time step; near-field ranges (typically â‰¤ 50 km); and cases where the effective plume height remains within the planetary boundary layer.\n\nWhat this does:\n\nStability classification: Uses near-surface meteorology (10 m wind speed, downward short-wave radiation, total cloud fraction, and the surface temperature lapse) to determine the Pasquill stability class.\nDispersion coefficients: Maps the stability class to Briggs coefficients (Ay, Az, By, Bz) and evaluates the analytic expressions for the horizontal (sigmah â‰¡ sigmay) and vertical (sigma_z) dispersion parameters as functions of the down-wind distance 'x'.\nHypsometric height: Computes puff height above ground (z_agl) from pressure, temperature, and humidity using the hypsometric equation with a virtual temperature layer mean.\nGround-level concentration: Computes the Gaussian ground-level concentration at the puff center for one unit of puff mass: Cgl = 1 / ((2Ï€)^{3/2} Â· ÏƒhÂ² Â· Ïƒz) * exp(-zaglÂ² / (2 Ïƒ_zÂ²)).\n\nExample:\n\nusing Dates, EarthSciMLBase, EarthSciData, EnvironmentalTransport\nusing ModelingToolkit, OrdinaryDiffEq\n\nt0 = DateTime(2022, 5, 1)\nt1 = DateTime(2022, 5, 2)\nÎ”Î»      = deg2rad(5.0)\nÎ”Ï†      = deg2rad(4.0)\n\ndom = DomainInfo(t0, t1; levrange=1:72,\n                    lonrange = deg2rad(-130):Î”Î»:deg2rad(-60),\n                    latrange = deg2rad(25):Î”Ï†:deg2rad(61))\n\nmdl = couple(Puff(dom),\n             GEOSFP(\"4x5\", dom; stream=false),\n             GaussianPGB())\n\nsys  = convert(System, mdl)\n\nu0 = [sys.Puffâ‚Šlon => deg2rad(-105),\n      sys.Puffâ‚Šlat => deg2rad(  38),\n      sys.Puffâ‚Šlev => 2]\n\np  = [sys.GaussianPGBâ‚Šlon0 => deg2rad(-105),\n      sys.GaussianPGBâ‚Šlat0 => deg2rad(  38)]\n\nprob = ODEProblem(sys, u0, (datetime2unix(t0), datetime2unix(t1)), p)\nsol = solve(prob, Tsit5();)\n\nsigma_h = sol[sys.GaussianPGBâ‚Šsigma_h]\nsigma_z = sol[sys.GaussianPGBâ‚Šsigma_z]\nC_gl    = sol[sys.GaussianPGBâ‚ŠC_gl]\n\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.GaussianSD-Tuple{}","page":"API","title":"EnvironmentalTransport.GaussianSD","text":"GaussianSD()\n\nReturns a ModelingToolkit.System that calculates horizontal dispersion (Ïƒh) from velocity deformation (Smagorinsky/Deardorff), and computes hypsometric height (zagl) and ground-level centerline concentration per unit mass. The ground-level concentration is only evaluated when the puff is within the ground layer (z_agl â‰¤ Î”z); otherwise it is set to zero.\n\nReferences (NOAA ARL MetMag report): https://www.arl.noaa.gov/documents/reports/MetMag.pdf\n\nHorizontal mixing coefficient: Eq. 12\nStandard deviation of the turbulent velocity: Eq. 15\nÏƒ_h tendency: Eq. 16\nCenterline ground-level concentration: Eq. 18\n\nExample:\n\nusing Dates, EarthSciMLBase, EarthSciData, EnvironmentalTransport\nusing ModelingToolkit, OrdinaryDiffEq\n\nt0 = DateTime(2022, 5, 1)\nt1 = DateTime(2022, 5, 2)\nÎ”Î»      = deg2rad(5.0)\nÎ”Ï†      = deg2rad(4.0)\n\ndom = DomainInfo(t0, t1; levrange=1:72,\n                    lonrange = deg2rad(-130):Î”Î»:deg2rad(-60),\n                    latrange = deg2rad(25):Î”Ï†:deg2rad(61))\n\nmdl = couple(Puff(dom),\n             GEOSFP(\"4x5\", dom; stream=false),\n             GaussianSD())\n\nsys  = convert(System, mdl)\n\nu0 = [sys.Puffâ‚Šlon => deg2rad(-105),\n      sys.Puffâ‚Šlat => deg2rad(  38),\n      sys.Puffâ‚Šlev => 2,\n      sys.GaussianSDâ‚Šsigma_h => 0.0]\n\np = [\n        sys.GaussianSDâ‚ŠÎ”Î» => Î”Î»,\n        sys.GaussianSDâ‚ŠÎ”Ï† => Î”Ï†]\n\nprob = ODEProblem(sys, u0, (datetime2unix(t0), datetime2unix(t1)), p)\nsol = solve(prob, Tsit5();)\n\nsigma_h = sol[sys.GaussianSDâ‚Šsigma_h]\nC_gl    = sol[sys.GaussianSDâ‚ŠC_gl]\n\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.Puff-Tuple{EarthSciMLBase.DomainInfo}","page":"API","title":"EnvironmentalTransport.Puff","text":"Puff(\n    di::EarthSciMLBase.DomainInfo;\n    buffer_cells,\n    name\n) -> ModelingToolkit.System\n\n\nCreate a Lagrangian transport model which advects a \"puff\" or particle of matter within a fluid velocity field.\n\nModel boundaries are set by the DomainInfo argument. The model sets boundaries at the ground and model bottom and top, preventing the puff from crossing those boundaries. If the puff reaches one of the horizontal boundaries, the simulation is stopped.\n\nKeyword arguments\n\nbuffer_cells: The distance (expressed in a number of DomainInfo grid cells) to use as a buffer around the horizontal edge of the domain to avoid data loader interpolation errors. The effective size of the domain will be reduce by 2Ã— this amount (default = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.Sofiev2012PlumeRise-Tuple{}","page":"API","title":"EnvironmentalTransport.Sofiev2012PlumeRise","text":"Wildfire plume rise model based on Sofiev et al. (2012) [1].\n\n[1] Sofiev, M., Ermakova, T., and Vankevich, R.: Evaluation of the smoke-injection height from wild-land fires using remote-sensing data, Atmos. Chem. Phys., 12, 1995â€“2006, https://doi.org/10.5194/acp-12-1995-2012, 2012.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.advection_kernel_4d","page":"API","title":"EnvironmentalTransport.advection_kernel_4d","text":"An advection kernel for a 4D array, where the first dimension is the state variables and the next three dimensions are the spatial dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#EnvironmentalTransport.advection_op-Tuple{Any, Any, Any, Any, Any, Any, EarthSciMLBase.MapAlgorithm}","page":"API","title":"EnvironmentalTransport.advection_op","text":"A function to create an advection operator for a 4D array,\n\nArguments:\n\nu_prototype: A prototype array of the same size and type as the input array.\nstencil: The stencil operator, e.g. l94_stencil or ppm_stencil.\nv_fs: A vector of functions to get the wind velocity at a given place and time. The function signature should be v_fs(i, j, k, t).\nÎ”_fs: A vector of functions to get the grid spacing at a given place and time. The function signature should be Î”_fs(i, j, k, t).\nÎ”t: The time step size, which is assumed to be fixed.\nbc_type: The boundary condition type, e.g. ZeroGradBC().\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.air_mass_from_pressure-Tuple{Vector{Float64}, Float64}","page":"API","title":"EnvironmentalTransport.air_mass_from_pressure","text":"Compute air mass for each layer from pressure edges and grid area.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.compute_imix_fpbl-Tuple{Vector{Float64}, Float64}","page":"API","title":"EnvironmentalTransport.compute_imix_fpbl","text":"Compute PBL mixing parameters based on domain levels.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.extract_domain_pressure_edges-Tuple{AbstractRange}","page":"API","title":"EnvironmentalTransport.extract_domain_pressure_edges","text":"Extract domain-specific pressure edges from the pre-computed 73-level GEOS-FP grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.get_vf-Tuple{Any, AbstractString, Any}","page":"API","title":"EnvironmentalTransport.get_vf","text":"get_vf(domain, varname, data_f)\n\n\nReturn a function that gets the wind velocity at a given place and time for the given varname. data_f should be a function that takes a time and three spatial coordinates and returns the value of the wind speed in the direction indicated by varname.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.get_Î”-Tuple{EarthSciMLBase.DomainInfo, Any, Any}","page":"API","title":"EnvironmentalTransport.get_Î”","text":"get_Î”(domain, tff, pvaridx)\n\n\nReturn a function that gets the grid spacing at a given place and time for the given varname.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.pbl_full_mix!-Tuple{Matrix{Float64}, Vector{Float64}, Int64, Float64}","page":"API","title":"EnvironmentalTransport.pbl_full_mix!","text":"Apply full PBL mixing to tracer concentrations (GEOS-Chem TURBDAY algorithm).\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.pbl_obs_function-NTuple{4, Any}","page":"API","title":"EnvironmentalTransport.pbl_obs_function","text":"pbl_obs_function(mtk_sys, coord_args, v, T)\n\nCreate an observed function for extracting data from the ModelingToolkit system.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.resolve_species_bc-Tuple{SpeciesConstantBC, Any, Any}","page":"API","title":"EnvironmentalTransport.resolve_species_bc","text":"resolve_species_bc(bc, x, species_vars)\n\n\nHelper function to resolve species names to indices and create a SpeciesConstantBCArray. This is used by AdvectionOperator when species information is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.stencil_size-Tuple{typeof(upwind1_stencil)}","page":"API","title":"EnvironmentalTransport.stencil_size","text":"Return the left and right stencil size of the first-order upwind stencil.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.upwind1_stencil-NTuple{4, Any}","page":"API","title":"EnvironmentalTransport.upwind1_stencil","text":"upwind1_stencil(Ï•, U, Î”t, Î”z; p)\n\n\nFirst-order upwind advection in 1-D: https://en.wikipedia.org/wiki/Upwind_scheme.\n\nÏ• is the scalar field at the current time step, it should be a vector of length 3 (1 cell on the left, the central cell, and 1 cell on the right).\nU is the velocity at both edges of the central grid cell, it should be a vector of length 2.\nÎ”t is the length of the time step.\nÎ”z is the grid spacing.\n\nThe output will be time derivative of the central index (i.e. index 2) of the Ï• vector (i.e. dÏ•/dt).\n\nÎ”t and p are not used, but are function arguments for consistency with other operators.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.vf_x-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.vf_x","text":"Get a value from the x-direction velocity field.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.vf_y-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.vf_y","text":"Get a value from the y-direction velocity field.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.vf_z-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.vf_z","text":"Get a value from the z-direction velocity field.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.Î”f-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.Î”f","text":"function to get grid deltas.\n\n\n\n\n\n","category":"method"},{"location":"#EnvironmentalTransport:-Algorithms-for-Environmental-Mass-Transport","page":"Home","title":"EnvironmentalTransport: Algorithms for Environmental Mass Transport","text":"Documentation for EnvironmentalTransport.jl.\n\nThis package contains algorithms for simulating environmental mass transport, for use with the EarthSciML ecosystem.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"EnvironmentalTransport\")","category":"section"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"This package contains types and functions designed to simplify the process of constructing and composing symbolically-defined Earth Science model components together.","category":"section"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"Numerical Advection\nGeneral Circulation (Coriolis parameter, geostrophic wind, thermal wind)","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing.","category":"section"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"<details><summary>The documentation of this EnvironmentalTransport package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nYou can also download the \n<a href=\"\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\")\n\n\">manifest</a> file and the\n<a href=\"\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\")\n\n\">project</a> file.","category":"section"},{"location":"advection/#Numerical-Advection-Operator","page":"Advection","title":"Numerical Advection Operator","text":"We have two ways to represent phenomena that occur across space such as advection: through symbolically-defined partial differential equation systems, which will be covered elsewhere in documentation, and through numerically-implemented algorithms. This is an example of the latter. (Currently, symbolically defined PDEs are too slow to be used in large-scale simulations.)\n\nTo demonstrate how it works, let's first set up our environment:\n\nusing EnvironmentalTransport\nusing EarthSciMLBase, EarthSciData\nusing ModelingToolkit, DifferentialEquations\nusing ProgressLogging\nusing ModelingToolkit: t, D\nusing DynamicQuantities\nusing Distributions, LinearAlgebra\nusing Dates\nusing NCDatasets, Plots\nnothing #hide","category":"section"},{"location":"advection/#Emissions","page":"Advection","title":"Emissions","text":"Next, let's set up an emissions scenario to advect. We'll make the emissions start at the beginning of the simulation and then taper off:\n\nstarttime = DateTime(2022, 5, 1)\nendtime = DateTime(2022, 5, 10)\n\nstruct EmissionsCoupler\n    sys\nend\nfunction emissions(Î¼_lon, Î¼_lat, Ïƒ)\n    @parameters(lon=-97.0, [unit=u\"rad\"],\n        lat=30.0, [unit=u\"rad\"],\n        lev=1.0,)\n    @variables c(t) = 0.0 [unit=u\"kg\"]\n    @constants v_emis = 50.0 [unit=u\"kg/s\"]\n    @constants t_unit = 1.0 [unit=u\"s\"] # Needed so that arguments to `pdf` are unitless.\n    dist = MvNormal([datetime2unix(starttime), Î¼_lon, Î¼_lat, 1],\n        Diagonal(map(abs2, [3600.0*24*3, Ïƒ, Ïƒ, 1])))\n    ODESystem([D(c) ~ pdf(dist, [t/t_unit, lon, lat, lev]) * v_emis],\n        t, name = :emissions, metadata = Dict(CoupleType => EmissionsCoupler))\nend\nfunction EarthSciMLBase.couple2(e::EmissionsCoupler, g::EarthSciData.GEOSFPCoupler)\n    e, g = e.sys, g.sys\n    e = param_to_var(e, :lat, :lon, :lev)\n    ConnectorSystem([e.lat ~ g.lat, e.lon ~ g.lon, e.lev ~ g.lev], e, g)\nend\n\nemis = emissions(deg2rad(-97.0), deg2rad(40.0), deg2rad(1))","category":"section"},{"location":"advection/#Coupled-System","page":"Advection","title":"Coupled System","text":"Next, let's set up a spatial and temporal domain for our simulation, and some input data from GEOS-FP to get wind fields for our advection. We need to use coord_defaults in this case to get the GEOS-FP data to work correctly, but it doesn't matter what the defaults are. We also set up an outputter to save the results of our simulation, and couple the components we've created so far into a single system.\n\n\ndomain = DomainInfo(\n    starttime, endtime;\n    lonrange = deg2rad(-115):deg2rad(1):deg2rad(-68.75),\n    latrange = deg2rad(25):deg2rad(1):deg2rad(53.7),\n    levrange = 1:1:15)\n\ngeosfp = GEOSFP(\"4x5\", domain)\ngeosfp = EarthSciMLBase.copy_with_change(geosfp, discrete_events = []) # Workaround for bug.\n\noutfile = (\"RUNNER_TEMP\" âˆˆ keys(ENV) ? ENV[\"RUNNER_TEMP\"] : tempname()) * \"out.nc\" # This is just a location to save the output.\noutput = NetCDFOutputter(outfile, 3600.0)\n\ncsys = couple(emis, domain, geosfp, output)","category":"section"},{"location":"advection/#Advection-Operator","page":"Advection","title":"Advection Operator","text":"Next, we create an AdvectionOperator to perform advection. We need to specify a time step (300 s in this case), as stencil algorithm to do the advection (current options are upwind1_stencil). We also specify zero gradient boundary conditions.\n\nThen, we couple the advection operator to the rest of the system.\n\nadv = AdvectionOperator(300.0, upwind1_stencil, ZeroGradBC())\n\ncsys = couple(csys, adv)\n\nNow, we initialize a ODEProblem to run our demonstration. We use the Tsit5 time integrator for our emissions system of equations, and a time integration scheme for our advection operator (SSPRK22 in this case). Refer here for the available time integrator choices. We also choose a operator splitting interval of 300 seconds. Then, we run the simulation.\n\nst = SolverStrangSerial(Tsit5(), 300.0)\nprob = ODEProblem(csys, st)\n\n@time solve(\n    prob, SSPRK22(), dt = 300, save_on = false, save_start = false, save_end = false,\n    initialize_save = false, progress = true, progress_steps = 1)","category":"section"},{"location":"advection/#Visualization","page":"Advection","title":"Visualization","text":"Finally, we can visualize the results of our simulation:\n\nds = NCDataset(outfile, \"r\")\n\nimax = argmax(reshape(maximum(ds[\"emissionsâ‚Šc\"][:, :, :, :], dims = (1, 3, 4)), :))\ngrid = EarthSciMLBase.grid(domain)\nanim = @animate for i in 1:size(ds[\"emissionsâ‚Šc\"])[4]\n    plot(\n        heatmap(rad2deg.(grid[1]), rad2deg.(grid[2]),\n            ds[\"emissionsâ‚Šc\"][:, :, 1, i]', title = \"Ground-Level\", xlabel = \"Longitude\", ylabel = \"Latitude\"),\n        heatmap(rad2deg.(grid[1]), grid[3], ds[\"emissionsâ‚Šc\"][:, imax, :, i]',\n            title = \"Vertical Cross-Section (lat=$(round(rad2deg(grid[2][imax]), digits=1)))\",\n            xlabel = \"Longitude\", ylabel = \"Vertical Level\"),\n        size = (1200, 400)\n    )\nend\ngif(anim, fps = 15)","category":"section"}]
}
