var documenterSearchIndex = {"docs":
[{"location":"puff/#Air-Pollution-\"Puff\"-Model-Example","page":"Puff Model","title":"Air Pollution \"Puff\" Model Example","text":"using EarthSciMLBase, EarthSciData, EnvironmentalTransport\nusing ModelingToolkit\nusing ModelingToolkit: t\nusing DynamicQuantities\nusing OrdinaryDiffEqDefault\nusing OrdinaryDiffEqTsit5: Tsit5\nusing SciMLBase: EnsembleProblem, remake\nusing Plots\nusing Dates\n\nfirestart = DateTime(2021, 10, 1)\nfirelength = 15 * 24 * 3600 # Seconds\nsimulationlength = 20 # Days\nfirelon = deg2rad(-97)\nfirelat = deg2rad(40)\nfireradius = deg2rad(0.05) # Degrees\nsamplerate = 3600.0 # Seconds\nsamples_per_time = 1 # Samples per each emission time\nfireheight = 2.0 # Vertical level (Allowing this to be automatically calculated is a work in progress).\nemis_rate = 1.0 # kg/s, fire emission rate\n\nsim_end = firestart + Day(simulationlength)\n\ndomain = DomainInfo(\n    firestart, sim_end;\n    lonrange = deg2rad(-115):deg2rad(1.25):deg2rad(-68.75),\n    latrange = deg2rad(25):deg2rad(1):deg2rad(53.7),\n    levrange = 1:72\n)\n\ngeosfp = GEOSFP(\"4x5\", domain; stream = false)\n\npuff = Puff(domain; buffer_cells=5)\n\nmodel = couple(puff, geosfp)\nconst sys = convert(System, model)\ntspan = EarthSciMLBase.get_tspan(domain)\nprob = ODEProblem(sys, [], tspan)\nsol = solve(prob, Tsit5()) # Solve once to make sure data is loaded.\n\nfunction prob_func(prob, i, repeat)\n    r = rand() * fireradius\n    Î¸ = rand() * 2Ï€\n    u0 = [\n        sys.Puffâ‚Šlon => firelon + r * cos(Î¸),\n        sys.Puffâ‚Šlat => firelat + r * sin(Î¸),\n        sys.Puffâ‚Šlev => fireheight\n    ]\n    ts = (tspan[1] + floor(i / samples_per_time) * samplerate, tspan[2])\n    remake(prob, u0 = u0, tspan = ts)\nend\neprob = EnsembleProblem(prob, prob_func = prob_func, safetycopy = false)\nesol = solve(eprob, Tsit5(); trajectories = ceil(firelength/samplerate*samples_per_time))\n\nvars = [sys.Puffâ‚Šlon, sys.Puffâ‚Šlat, sys.Puffâ‚Šlev]\nvaridxs = ModelingToolkit.variable_index.((sys,), vars)\nranges = [(Inf, -Inf), (Inf, -Inf), (Inf, -Inf)]\nfor sol in esol\n    for (i, var) in enumerate(vars)\n        rng = (minimum(sol[var]), maximum(sol[var]))\n        ranges[i] = (min(ranges[i][1], rng[1]),\n            max(ranges[i][2], rng[2]))\n    end\nend\n\nt_ref = get_tref(domain)\nanim = @animate for dt in datetime2unix(firestart):samplerate:datetime2unix(sim_end)\n    t = dt - t_ref\n    p = plot(\n        xlim = rad2deg.(ranges[1]), ylim = rad2deg.(ranges[2]), zlim = ranges[3],\n        title = \"Time: $(unix2datetime(t + t_ref))\",\n        xlabel = \"Longitude (deg)\", ylabel = \"Latitude (deg)\",\n        zlabel = \"Vertical Level\"\n    )\n    for sol in esol\n        if t < sol.t[1] || t > sol.t[end]\n            continue\n        end\n        lon, lat, lev = sol(t)[varidxs[1]], sol(t)[varidxs[2]], sol(t)[varidxs[3]]\n        color = lev < 2 ? :red : :black\n        scatter!(p,\n            [rad2deg(sol(t)[varidxs[1]])], [rad2deg(sol(t)[varidxs[2]])], [sol(t)[varidxs[3]]],\n            label = :none, markercolor = color, markerstrokecolor = color, markersize = 1.5\n        )\n    end\nend\ngif(anim, fps = 15)","category":"section"},{"location":"benchmarks/#Redirecting...","page":"ðŸ”— Benchmarks","title":"Redirecting...","text":"<html>\n<head>\n    <meta http-equiv=\"refresh\" content=\"0; url=https://transport.earthsci.dev/benchmarks/\" />\n</head>\n<body>\n    <p>If you are not redirected automatically, follow this <a href=\"https://transport.earthsci.dev/benchmarks/\">link</a>.</p>\n</body>\n</html>","category":"section"},{"location":"api/#API-Index","page":"API","title":"API Index","text":"","category":"section"},{"location":"api/#API-Documentation","page":"API","title":"API Documentation","text":"","category":"section"},{"location":"api/#EnvironmentalTransport.AdvectionOperator","page":"API","title":"EnvironmentalTransport.AdvectionOperator","text":"Create an EarthSciMLBase.Operator that performs advection. Advection is performed using the given stencil operator (e.g. l94_stencil or ppm_stencil). p is an optional parameter set to be used by the stencil operator. bc_type is the boundary condition type, e.g. ZeroGradBC().\n\nWind field data will be added in automatically if available. Currently the only valid source of wind data is EarthSciData.GEOSFP.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.BCArray","page":"API","title":"EnvironmentalTransport.BCArray","text":"An array with external indexing implemented for boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ConstantBC","page":"API","title":"EnvironmentalTransport.ConstantBC","text":"Constant boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ConstantBCArray","page":"API","title":"EnvironmentalTransport.ConstantBCArray","text":"An array with zero constant boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.PBLMixingCallback","page":"API","title":"EnvironmentalTransport.PBLMixingCallback","text":"PBLMixingCallback <: EarthSciMLBase.Operator\n\nA callback that applies planetary boundary layer (PBL) mixing to tracer fields at periodic intervals. PBL mixing is a discrete process that redistributes tracers vertically within each grid column.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.SpeciesConstantBC","page":"API","title":"EnvironmentalTransport.SpeciesConstantBC","text":"Species-specific constant boundary conditions. Takes a dictionary mapping species names/indices to boundary values and a default value.\n\nExamples:\n\nSpeciesConstantBC(Dict(\"O3\" => 40.0), 0.0) sets O3 to 40.0 and others to 0.0\nSpeciesConstantBC(Dict(1 => 40.0), 0.0) sets species 1 to 40.0 and others to 0.0\nSpeciesConstantBC(Dict(\"O3\" => 40.0, \"NO2\" => 10.0), 0.0) sets multiple species\n\nNote: When using species names, they will be resolved to indices when the boundary condition is applied to a system with known species variables.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.SpeciesConstantBCArray","page":"API","title":"EnvironmentalTransport.SpeciesConstantBCArray","text":"An array with species-specific constant boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ZeroGradBC","page":"API","title":"EnvironmentalTransport.ZeroGradBC","text":"Zero gradient boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EnvironmentalTransport.ZeroGradBCArray","page":"API","title":"EnvironmentalTransport.ZeroGradBCArray","text":"An array with zero gradient boundary conditions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EarthSciMLBase.init_callback-Tuple{PBLMixingCallback, EarthSciMLBase.CoupledSystem, Any, Any, EarthSciMLBase.DomainInfo, Any}","page":"API","title":"EarthSciMLBase.init_callback","text":"EarthSciMLBase.init_callback(cb::PBLMixingCallback, csys::CoupledSystem, sys_mtk, coord_args, domain::DomainInfo, alg)\n\nInitialize the PBL mixing callback.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.BoundaryLayerMixingKC-Tuple{}","page":"API","title":"EnvironmentalTransport.BoundaryLayerMixingKC","text":"BoundaryLayerMixingKC()\n\nA ModelingToolkit System implementing the Kantha-Clayson & Garratt turbulence parameterization for boundary layer mixing, as described in NOAA ARL-224 (https://www.arl.noaa.gov/documents/reports/arl-224.pdf) and HYSPLIT documentation.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.GaussianKC-Tuple{}","page":"API","title":"EnvironmentalTransport.GaussianKC","text":"GaussianKC()\n\nReturns a ModelingToolkit.System that calculates the time evolution of horizontal puff dispersion (sigmax, sigmay) based on turbulent velocity fluctuations (Ïƒux, Ïƒuy).\n\nIt also computes the ground-level centerline concentration (Cgl) per unit mass assuming a top-hat vertical distribution within the lowest layer. The concentration is evaluated only when the puff is within the surface layer (zagl â‰¤ Î”z); otherwise, it is set to zero.\n\nNote: Must be coupled with BoundaryLayerMixingKC.\n\nExample:\n\nusing Dates, EarthSciMLBase, EarthSciData, EnvironmentalTransport\nusing ModelingToolkit, StochasticDiffEq\n\nt0 = DateTime(2022, 5, 1)\nt1 = DateTime(2022, 5, 2)\nÎ”Î»      = deg2rad(5.0)\nÎ”Ï†      = deg2rad(4.0)\n\ndom = DomainInfo(t0, t1;\n                    lonrange = deg2rad(-130):Î”Î»:deg2rad(-60),\n                    latrange = deg2rad(25):Î”Ï†:deg2rad(61)),\n                    levrange=1:72\n\nmdl = couple(Puff(dom),\n             BoundaryLayerMixingKC(),\n             GEOSFP(\"4x5\", dom; stream=false),\n             GaussianKC())\n\nsys  = convert(System, mdl)\ntspan = get_tspan(dom)\n\nu0 = [sys.Puffâ‚Šlon => deg2rad(-105),\n      sys.Puffâ‚Šlat => deg2rad(  38),\n      sys.Puffâ‚Šlev => 2,\n      sys.GaussianKCâ‚Šsigma_x => 0.00001,\n      sys.GaussianKCâ‚Šsigma_y => 0.00001,\n      sys.BoundaryLayerMixingKCâ‚Šwprime => 0.0,\n      sys.BoundaryLayerMixingKCâ‚Šuprime_x => 0.0,\n      sys.BoundaryLayerMixingKCâ‚Šuprime_y => 0.0]\n\np = [sys.GaussianKCâ‚ŠÎ”z => 100.0]\n\nprob = SDEProblem(sys, u0, tspan, p)\nsol = solve(prob, SRIW1(); dt=60.0)\n\nsigma_x = sol[sys.GaussianKCâ‚Šsigma_x]\nsigma_y = sol[sys.GaussianKCâ‚Šsigma_y]\nC_gl    = sol[sys.GaussianKCâ‚ŠC_gl]\n\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.GaussianPGB-Tuple{}","page":"API","title":"EnvironmentalTransport.GaussianPGB","text":"GaussianPGB()\n\nReturn a ModelingToolkit.System implementing a classic Gaussian plume dispersion model, parameterized with Pasquill-Gifford-Briggs dispersion coefficients, following the formulations described in EPA guidance 402-R-00-004 Â§12.1.6 (https://19january2017snapshot.epa.gov/sites/production/files/2015-05/documents/402-r-00-004.pdf) and the MMGRMA document, Table 6-7 (https://www.epa.gov/sites/default/files/2020-10/documents/mmgrma_0.pdf). Good for: quasi-steady (piecewise-steady) applications where emissions and meteorology can be treated steady over each model time step; near-field ranges (typically â‰¤ 50 km); and cases where the effective plume height remains within the planetary boundary layer.\n\nWhat this does:\n\nStability classification: Uses near-surface meteorology (10 m wind speed, downward short-wave radiation, total cloud fraction, and the surface temperature lapse) to determine the Pasquill stability class.\nDispersion coefficients: Maps the stability class to Briggs coefficients (Ay, Az, By, Bz) and evaluates the analytic expressions for the horizontal (sigmah â‰¡ sigmay) and vertical (sigma_z) dispersion parameters as functions of the down-wind distance 'x'.\nHypsometric height: Computes puff height above ground (z_agl) from pressure, temperature, and humidity using the hypsometric equation with a virtual temperature layer mean.\nGround-level concentration: Computes the Gaussian ground-level concentration at the puff center for one unit of puff mass: Cgl = 1 / ((2Ï€)^{3/2} Â· ÏƒhÂ² Â· Ïƒz) * exp(-zaglÂ² / (2 Ïƒ_zÂ²)).\n\nExample:\n\nusing Dates, EarthSciMLBase, EarthSciData, EnvironmentalTransport\nusing ModelingToolkit, OrdinaryDiffEq\n\nt0 = DateTime(2022, 5, 1)\nt1 = DateTime(2022, 5, 2)\nÎ”Î»      = deg2rad(5.0)\nÎ”Ï†      = deg2rad(4.0)\n\ndom = DomainInfo(t0, t1; levrange=1:72,\n                    lonrange = deg2rad(-130):Î”Î»:deg2rad(-60),\n                    latrange = deg2rad(25):Î”Ï†:deg2rad(61))\n\nmdl = couple(Puff(dom),\n             GEOSFP(\"4x5\", dom; stream=false),\n             GaussianPGB())\n\nsys  = convert(System, mdl)\ntspan = get_tspan(dom)\n\nu0 = [sys.Puffâ‚Šlon => deg2rad(-105),\n      sys.Puffâ‚Šlat => deg2rad(  38),\n      sys.Puffâ‚Šlev => 2]\n\np  = [sys.GaussianPGBâ‚Šlon0 => deg2rad(-105),\n      sys.GaussianPGBâ‚Šlat0 => deg2rad(  38)]\n\nprob = ODEProblem(sys, u0, tspan, p)\nsol = solve(prob, Tsit5();)\n\nsigma_h = sol[sys.GaussianPGBâ‚Šsigma_h]\nsigma_z = sol[sys.GaussianPGBâ‚Šsigma_z]\nC_gl    = sol[sys.GaussianPGBâ‚ŠC_gl]\n\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.HeavisideBoundaryCondition-Tuple{}","page":"API","title":"EnvironmentalTransport.HeavisideBoundaryCondition","text":"HeavisideBoundaryCondition(\n;\n    name\n) -> ModelingToolkitBase.System\n\n\nCreate a smoothed Heaviside boundary condition component for coupling surface and subsurface water flow, following Wang et al. (2020).\n\nThe Heaviside step function determines whether the soil surface is in a ponding state (h â‰¥ 0) or unsaturated state (h < 0), enabling automatic switching between infiltration and evaporation boundary conditions:\n\neta_omega(h) = frac1pi arctanleft(frachomegaright) + frac12\n\ndelta_omega(h) = frac1pi fracomegaomega^2 + h^2\n\nThese smooth approximations converge to the Heaviside step function and Dirac delta function respectively as omega to 0^+.\n\nThe boundary condition equation is (Eq. 3):\n\nfracpartial(eta(h) cdot h)partial t - (P - I) = 0\n\nReference: Wang, Z., Timlin, D., Kouznetsov, M., Fleisher, D., Li, S., Tully, K., & Reddy, V. (2020). Coupled model of surface runoff and surface-subsurface water movement. Advances in Water Resources, 137, 103499. https://doi.org/10.1016/j.advwatres.2019.103499\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.Puff-Tuple{EarthSciMLBase.DomainInfo}","page":"API","title":"EnvironmentalTransport.Puff","text":"Puff(\n    di::EarthSciMLBase.DomainInfo;\n    buffer_cells,\n    name\n) -> ModelingToolkitBase.System\n\n\nCreate a Lagrangian transport model which advects a \"puff\" or particle of matter within a fluid velocity field.\n\nModel boundaries are set by the DomainInfo argument. The model sets boundaries at the ground and model bottom and top, preventing the puff from crossing those boundaries. If the puff reaches one of the horizontal boundaries, the simulation is stopped.\n\nKeyword arguments\n\nbuffer_cells: The distance (expressed in a number of DomainInfo grid cells) to use as a buffer around the horizontal edge of the domain to avoid data loader interpolation errors. The effective size of the domain will be reduce by 2Ã— this amount (default = 1)\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.SaintVenantPDE-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.SaintVenantPDE","text":"SaintVenantPDE(\n    L_domain,\n    T_end;\n    P_val,\n    I_val,\n    S_0_val,\n    n_manning_val,\n    g_val,\n    h_min_val,\n    h_init_val,\n    q_init_val,\n    name\n) -> ModelingToolkitBase.PDESystem\n\n\nCreate a PDESystem for the Saint-Venant equations (Eq. 1 from Wang et al., 2020) suitable for spatial discretization with MethodOfLines.jl.\n\nThe system implements the full 1D Saint-Venant equations with proper SI units:\n\nMass conservation (Eq. 1a): partial tildehpartial t = -partial qpartial l + (P - I)\nMomentum conservation (Eq. 1b): partial qpartial t = -partial Fpartial l + g tildeh(S_0 - S_f)\nMomentum flux (auxiliary): F = q^2tildeh + g tildeh^22\n\nwhere S_f is Manning's friction slope computed with non-dimensionalized fractional exponents: S_f = ((nn_ref)(qq_ref))^2  (tildehh_ref)^103.\n\nArguments\n\nL_domain: Length of the spatial domain (m)\nT_end: Duration of the simulation (s)\n\nKeyword Arguments\n\nP_val: Precipitation rate (m/s), default 70 mm/hr\nI_val: Infiltration rate (m/s), default 0.0\nS_0_val: Surface slope (dimensionless), default 0.01\nn_manning_val: Manning roughness coefficient (m^(-1/3)Â·s), default 0.03\ng_val: Gravitational acceleration (m/sÂ²), default 9.81\nh_min_val: Minimum flow depth to prevent singularity (m), default 1e-5\nh_init_val: Initial and boundary flow depth (m), default 1e-3\nq_init_val: Initial and boundary flux (mÂ²/s), default 0.0\nname: System name, default :SaintVenantPDE\n\nReference: Wang, Z., Timlin, D., Kouznetsov, M., Fleisher, D., Li, S., Tully, K., & Reddy, V. (2020). Coupled model of surface runoff and surface-subsurface water movement. Advances in Water Resources, 137, 103499. https://doi.org/10.1016/j.advwatres.2019.103499\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.Sofiev2012PlumeRise-Tuple{}","page":"API","title":"EnvironmentalTransport.Sofiev2012PlumeRise","text":"Wildfire plume rise model based on Sofiev et al. (2012) [1].\n\n[1] Sofiev, M., Ermakova, T., and Vankevich, R.: Evaluation of the smoke-injection height from wild-land fires using remote-sensing data, Atmos. Chem. Phys., 12, 1995â€“2006, https://doi.org/10.5194/acp-12-1995-2012, 2012.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.SurfaceRunoff-Tuple{}","page":"API","title":"EnvironmentalTransport.SurfaceRunoff","text":"SurfaceRunoff(; name) -> ModelingToolkitBase.System\n\n\nCreate a surface runoff model based on the Saint-Venant equation system for surface water movement, following the approach of Wang et al. (2020).\n\nThe model describes mass conservation and momentum conservation of surface water flow along a soil surface slope. The Saint-Venant equations are:\n\nfracpartial tildehpartial t = -fracpartial qpartial l + (P - I)\n\nfracpartial qpartial t = -fracpartialpartial lleft(fracq^2tildeh + fracg tildeh^22right) + g tildeh (S_0 - S_f)\n\nwhere tildeh is the flow depth (ponded water height), q is the surface runoff flux per unit width, P is precipitation flux, I is infiltration flux, S_0 is the surface slope, and S_f is the friction slope computed from Manning's equation.\n\nThis component represents the equations at a single surface node. The spatial derivative terms (partial q  partial l and the momentum flux divergence) are represented as input parameters that should be provided by a spatial discretization scheme or coupled model.\n\nReference: Wang, Z., Timlin, D., Kouznetsov, M., Fleisher, D., Li, S., Tully, K., & Reddy, V. (2020). Coupled model of surface runoff and surface-subsurface water movement. Advances in Water Resources, 137, 103499. https://doi.org/10.1016/j.advwatres.2019.103499\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.advection_kernel_4d","page":"API","title":"EnvironmentalTransport.advection_kernel_4d","text":"An advection kernel for a 4D array, where the first dimension is the state variables and the next three dimensions are the spatial dimensions.\n\n\n\n\n\n","category":"function"},{"location":"api/#EnvironmentalTransport.advection_op-Tuple{Any, Any, Any, Any, Any, Any, EarthSciMLBase.MapAlgorithm}","page":"API","title":"EnvironmentalTransport.advection_op","text":"A function to create an advection operator for a 4D array,\n\nArguments:\n\nu_prototype: A prototype array of the same size and type as the input array.\nstencil: The stencil operator, e.g. l94_stencil or ppm_stencil.\nv_fs: A vector of functions to get the wind velocity at a given place and time. The function signature should be v_fs(i, j, k, t).\nÎ”_fs: A vector of functions to get the grid spacing at a given place and time. The function signature should be Î”_fs(i, j, k, t).\nÎ”t: The time step size, which is assumed to be fixed.\nbc_type: The boundary condition type, e.g. ZeroGradBC().\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.air_mass_from_pressure-Tuple{Vector{Float64}, Float64}","page":"API","title":"EnvironmentalTransport.air_mass_from_pressure","text":"Compute air mass for each layer from pressure edges and grid area.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.compute_imix_fpbl-Tuple{Vector{Float64}, Float64}","page":"API","title":"EnvironmentalTransport.compute_imix_fpbl","text":"Compute PBL mixing parameters based on domain levels.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.extract_domain_pressure_edges-Tuple{AbstractRange}","page":"API","title":"EnvironmentalTransport.extract_domain_pressure_edges","text":"Extract domain-specific pressure edges from the pre-computed 73-level GEOS-FP grid.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.get_vf-Tuple{Any, AbstractString, Any}","page":"API","title":"EnvironmentalTransport.get_vf","text":"get_vf(domain, varname, data_f)\n\n\nReturn a function that gets the wind velocity at a given place and time for the given varname. data_f should be a function that takes a time and three spatial coordinates and returns the value of the wind speed in the direction indicated by varname.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.get_Î”-Tuple{EarthSciMLBase.DomainInfo, Any, Any}","page":"API","title":"EnvironmentalTransport.get_Î”","text":"get_Î”(domain, tff, pvaridx)\n\n\nReturn a function that gets the grid spacing at a given place and time for the given varname.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.pbl_full_mix!-Tuple{Matrix{Float64}, Vector{Float64}, Int64, Float64}","page":"API","title":"EnvironmentalTransport.pbl_full_mix!","text":"Apply full PBL mixing to tracer concentrations (GEOS-Chem TURBDAY algorithm).\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.pbl_obs_function-NTuple{4, Any}","page":"API","title":"EnvironmentalTransport.pbl_obs_function","text":"pbl_obs_function(mtk_sys, coord_args, v, T)\n\nCreate an observed function for extracting data from the ModelingToolkit system.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.resolve_species_bc-Tuple{SpeciesConstantBC, Any, Any}","page":"API","title":"EnvironmentalTransport.resolve_species_bc","text":"resolve_species_bc(bc, x, species_vars)\n\n\nHelper function to resolve species names to indices and create a SpeciesConstantBCArray. This is used by AdvectionOperator when species information is available.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.stencil_size-Tuple{typeof(upwind1_stencil)}","page":"API","title":"EnvironmentalTransport.stencil_size","text":"Return the left and right stencil size of the first-order upwind stencil.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.upwind1_stencil-NTuple{4, Any}","page":"API","title":"EnvironmentalTransport.upwind1_stencil","text":"upwind1_stencil(Ï•, U, Î”t, Î”z; p)\n\n\nFirst-order upwind advection in 1-D: https://en.wikipedia.org/wiki/Upwind_scheme.\n\nÏ• is the scalar field at the current time step, it should be a vector of length 3 (1 cell on the left, the central cell, and 1 cell on the right).\nU is the velocity at both edges of the central grid cell, it should be a vector of length 2.\nÎ”t is the length of the time step.\nÎ”z is the grid spacing.\n\nThe output will be time derivative of the central index (i.e. index 2) of the Ï• vector (i.e. dÏ•/dt).\n\nÎ”t and p are not used, but are function arguments for consistency with other operators.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.vf_x-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.vf_x","text":"Get a value from the x-direction velocity field.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.vf_y-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.vf_y","text":"Get a value from the y-direction velocity field.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.vf_z-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.vf_z","text":"Get a value from the z-direction velocity field.\n\n\n\n\n\n","category":"method"},{"location":"api/#EnvironmentalTransport.Î”f-Tuple{Any, Any}","page":"API","title":"EnvironmentalTransport.Î”f","text":"function to get grid deltas.\n\n\n\n\n\n","category":"method"},{"location":"surface_runoff/#Surface-Runoff-Model","page":"Surface Runoff","title":"Surface Runoff Model","text":"","category":"section"},{"location":"surface_runoff/#Overview","page":"Surface Runoff","title":"Overview","text":"This module implements a surface runoff model based on the Saint-Venant equation system for surface water movement, coupled with a Heaviside step function boundary condition for surface-subsurface water flow interaction.\n\nThe Saint-Venant equations describe the mass conservation and momentum conservation of surface water flow along a soil surface slope. The Heaviside boundary condition enables automatic switching between infiltration and evaporation conditions at the soil surface based on the soil water pressure head.\n\nThe model includes three key processes:\n\nSurface water flow along the soil surface (Saint-Venant equations)\nFriction effects via Manning's roughness equation\nAutomatic surface-subsurface boundary condition switching (Heaviside function)\n\nReference: Wang, Z., Timlin, D., Kouznetsov, M., Fleisher, D., Li, S., Tully, K., & Reddy, V. (2020). Coupled model of surface runoff and surface-subsurface water movement. Advances in Water Resources, 137, 103499. https://doi.org/10.1016/j.advwatres.2019.103499","category":"section"},{"location":"surface_runoff/#Soil-Properties-(Table-1)","page":"Surface Runoff","title":"Soil Properties (Table 1)","text":"The following table lists the soil physics properties and parameters for soil hydraulic models used in the numerical examples of Wang et al. (2020). Values are shown in the original paper units with SI equivalents.\n\nParameter Soil A Soil B SI Unit\nResidual Water Content (theta_r) 0.02 0.02 m^3 m^-3\nSaturated Water Content (theta_s) 0.33 0.52 m^3 m^-3\nvan Genuchten Parameter (alpha) 0.04 (cm^-1) = 4.0 (m^-1) 0.03 (cm^-1) = 3.0 (m^-1) m^-1\nvan Genuchten Parameter (n) 2.0 1.1 dimensionless\nSaturated Hydraulic Conductivity (k_s) 62.4 cm day^-1 = 7.22times 10^-6 m s^-1 1.0 cm day^-1 = 1.16times 10^-7 m s^-1 m s^-1\nSoil Bulk Density (rho_b) 1.51 g cm^-3 = 1510 kg m^-3 1.2 g cm^-3 = 1200 kg m^-3 kg m^-3\nMass Fraction of Soil Organic Matter 0.04 0.04 kg kg^-1\nMass Fraction of Sand 0.95 0.25 kg kg^-1\nMass Fraction of Silt 0.04 0.15 kg kg^-1","category":"section"},{"location":"surface_runoff/#Implementation","page":"Surface Runoff","title":"Implementation","text":"","category":"section"},{"location":"surface_runoff/#SurfaceRunoff-Component","page":"Surface Runoff","title":"SurfaceRunoff Component","text":"The SurfaceRunoff component implements the Saint-Venant equation system (Eq. 1 from Wang et al., 2020) at a single surface computing node.","category":"section"},{"location":"surface_runoff/#State-Variables","page":"Surface Runoff","title":"State Variables","text":"using DataFrames, ModelingToolkit, Symbolics, DynamicQuantities\nusing EnvironmentalTransport\n\nsys = SurfaceRunoff()\nvars = unknowns(sys)\nDataFrame(\n    :Name => [string(Symbolics.tosymbol(v, escape = false)) for v in vars],\n    :Units => [string(dimension(ModelingToolkit.get_unit(v))) for v in vars],\n    :Description => [ModelingToolkit.getdescription(v) for v in vars]\n)","category":"section"},{"location":"surface_runoff/#Parameters","page":"Surface Runoff","title":"Parameters","text":"params = parameters(sys)\nDataFrame(\n    :Name => [string(Symbolics.tosymbol(p, escape = false)) for p in params],\n    :Units => [try string(dimension(ModelingToolkit.get_unit(p))) catch; \"dimensionless\" end for p in params],\n    :Description => [ModelingToolkit.getdescription(p) for p in params]\n)","category":"section"},{"location":"surface_runoff/#Equations","page":"Surface Runoff","title":"Equations","text":"eqs = equations(sys)","category":"section"},{"location":"surface_runoff/#HeavisideBoundaryCondition-Component","page":"Surface Runoff","title":"HeavisideBoundaryCondition Component","text":"The HeavisideBoundaryCondition component implements the smoothed Heaviside step function (Eq. 5) and the surface boundary condition (Eq. 3) for coupling surface and subsurface water flow.","category":"section"},{"location":"surface_runoff/#State-Variables-2","page":"Surface Runoff","title":"State Variables","text":"hbc = HeavisideBoundaryCondition()\nvars_hbc = unknowns(hbc)\nDataFrame(\n    :Name => [string(Symbolics.tosymbol(v, escape = false)) for v in vars_hbc],\n    :Units => [try string(dimension(ModelingToolkit.get_unit(v))) catch; \"dimensionless\" end for v in vars_hbc],\n    :Description => [ModelingToolkit.getdescription(v) for v in vars_hbc]\n)","category":"section"},{"location":"surface_runoff/#Parameters-2","page":"Surface Runoff","title":"Parameters","text":"params_hbc = parameters(hbc)\nDataFrame(\n    :Name => [string(Symbolics.tosymbol(p, escape = false)) for p in params_hbc],\n    :Units => [try string(dimension(ModelingToolkit.get_unit(p))) catch; \"dimensionless\" end for p in params_hbc],\n    :Description => [ModelingToolkit.getdescription(p) for p in params_hbc]\n)","category":"section"},{"location":"surface_runoff/#Equations-2","page":"Surface Runoff","title":"Equations","text":"eqs_hbc = equations(hbc)","category":"section"},{"location":"surface_runoff/#Analysis","page":"Surface Runoff","title":"Analysis","text":"","category":"section"},{"location":"surface_runoff/#Smoothed-Heaviside-Step-Function-(Eq.-5)","page":"Surface Runoff","title":"Smoothed Heaviside Step Function (Eq. 5)","text":"The smoothed Heaviside function eta_omega(h) transitions from 0 to 1 around h = 0, with the sharpness controlled by the parameter omega. Smaller values of omega produce a sharper transition, approaching the true Heaviside step function.\n\nusing OrdinaryDiffEqDefault\nusing Plots\n\n# Evaluate Î·_Ï‰ for different Ï‰ values\nh_range = range(-0.01, 0.01, length=500)\n\np = plot(xlabel=\"Soil water pressure head h (m)\",\n         ylabel=\"Î·_Ï‰(h)\",\n         title=\"Smoothed Heaviside Step Function (Eq. 5)\")\n\nfor Ï‰_val in [1e-2, 1e-3, 1e-4]\n    Î·_vals = [(1/Ï€) * atan(h / Ï‰_val) + 0.5 for h in h_range]\n    plot!(p, h_range, Î·_vals, label=\"Ï‰ = $Ï‰_val m\", linewidth=2)\nend\n\np","category":"section"},{"location":"surface_runoff/#Smoothed-Dirac-Delta-Function-(Eq.-5)","page":"Surface Runoff","title":"Smoothed Dirac Delta Function (Eq. 5)","text":"The smoothed Dirac delta function delta_omega(h) is the derivative of the smoothed Heaviside function. It peaks at h = 0 with amplitude 1(piomega).\n\np2 = plot(xlabel=\"Soil water pressure head h (m)\",\n          ylabel=\"Î´_Ï‰(h) (1/m)\",\n          title=\"Smoothed Dirac Delta Function (Eq. 5)\")\n\nfor Ï‰_val in [1e-2, 1e-3, 1e-4]\n    Î´_vals = [(1/Ï€) * Ï‰_val / (Ï‰_val^2 + h^2) for h in h_range]\n    plot!(p2, h_range, Î´_vals, label=\"Ï‰ = $Ï‰_val m\", linewidth=2)\nend\n\np2","category":"section"},{"location":"surface_runoff/#Boundary-Condition-Transition:-Unsaturated-to-Ponding","page":"Surface Runoff","title":"Boundary Condition Transition: Unsaturated to Ponding","text":"This example demonstrates the automatic switching behavior of the Heaviside boundary condition (Eq. 3). Starting from an unsaturated state (h  0), precipitation drives the soil water pressure head toward positive values, transitioning from unsaturated to ponded conditions.\n\nhbc = HeavisideBoundaryCondition()\nchbc = mtkcompile(hbc)\n\n# Scenario: Start unsaturated, apply precipitation with partial infiltration\nprob = ODEProblem(chbc,\n    merge(\n        Dict(chbc.h => -0.05),\n        Dict(chbc.P => 1e-5, chbc.I_infil => 0.0, chbc.Ï‰ => 1e-3)\n    ),\n    (0.0, 20000.0))\nsol = solve(prob)\n\np3 = plot(sol.t, sol[chbc.h] .* 100,\n     xlabel=\"Time (s)\", ylabel=\"Pressure head h (cm)\",\n     title=\"Boundary Condition Transition (Eq. 3)\",\n     label=\"h(t)\", linewidth=2, legend=:bottomright)\nhline!(p3, [0.0], linestyle=:dash, color=:red, label=\"h = 0 (ponding threshold)\")\n\np3","category":"section"},{"location":"surface_runoff/#Manning's-Friction-Effect-on-Surface-Runoff","page":"Surface Runoff","title":"Manning's Friction Effect on Surface Runoff","text":"This example shows how Manning's roughness coefficient affects the friction slope and thus the momentum balance in the Saint-Venant equations (Eq. 1). Higher roughness produces greater friction, reducing flow velocity. Note that this single-node model demonstrates the local momentum response; in a full spatial simulation, the spatial flux terms would transport momentum downstream.\n\nsys_sr = SurfaceRunoff()\ncsys = mtkcompile(sys_sr)\n\n# Compare different Manning coefficients with steady precipitation\n# Using a short time window to observe the initial momentum response\np4 = plot(xlabel=\"Time (s)\", ylabel=\"Runoff flux q (mÂ²/s)\",\n          title=\"Effect of Manning's Roughness on Runoff (Eq. 1)\",\n          legend=:topleft)\n\nfor (n_val, label) in [(0.01, \"n=0.01 (smooth)\"),\n                        (0.03, \"n=0.03 (bare soil)\"),\n                        (0.10, \"n=0.10 (dense grass)\")]\n    prob_sr = ODEProblem(csys,\n        merge(\n            Dict(csys.hÌƒ => 1e-3, csys.q => 0.0),\n            Dict(\n                csys.P => 2e-5,\n                csys.I_infil => 1e-5,\n                csys.S_0 => 0.01,\n                csys.n_mann => n_val,\n                csys.hÌƒ_0 => 1e-5,\n                csys.dqdl => 0.0,\n                csys.dFdl => 0.0,\n            )\n        ),\n        (0.0, 5.0))\n    sol_sr = solve(prob_sr)\n    plot!(p4, sol_sr.t, sol_sr[csys.q], label=label, linewidth=2)\nend\n\np4","category":"section"},{"location":"surface_runoff/#Water-Depth-Accumulation-Under-Different-Precipitation-Infiltration-Regimes","page":"Surface Runoff","title":"Water Depth Accumulation Under Different Precipitation-Infiltration Regimes","text":"This example demonstrates the mass conservation equation (Eq. 1a) under different net water input scenarios, showing how the balance between precipitation and infiltration controls ponded water depth.\n\np5 = plot(xlabel=\"Time (s)\", ylabel=\"Flow depth hÌƒ (m)\",\n          title=\"Water Depth vs. Net Water Input (Eq. 1a)\",\n          legend=:topleft)\n\nfor (P_val, I_val, label) in [\n    (3e-5, 1e-5, \"P=3e-5, I=1e-5 (net gain)\"),\n    (2e-5, 2e-5, \"P=2e-5, I=2e-5 (balanced)\"),\n    (1e-5, 2e-5, \"P=1e-5, I=2e-5 (net loss)\")]\n    prob_acc = ODEProblem(csys,\n        merge(\n            Dict(csys.hÌƒ => 0.005, csys.q => 0.0),\n            Dict(\n                csys.P => P_val,\n                csys.I_infil => I_val,\n                csys.S_0 => 0.0,\n                csys.n_mann => 0.03,\n                csys.hÌƒ_0 => 1e-5,\n                csys.dqdl => 0.0,\n                csys.dFdl => 0.0,\n            )\n        ),\n        (0.0, 200.0))\n    sol_acc = solve(prob_acc)\n    plot!(p5, sol_acc.t, sol_acc[csys.hÌƒ], label=label, linewidth=2)\nend\n\np5","category":"section"},{"location":"surface_runoff/#PDE-Spatial-Solution-with-MethodOfLines.jl","page":"Surface Runoff","title":"PDE Spatial Solution with MethodOfLines.jl","text":"The full Saint-Venant equations (Eq. 1 from Wang et al., 2020) can be solved as a PDE system using MethodOfLines.jl for spatial discretization via the method of lines (finite differences).\n\nThe SaintVenantPDE function creates a PDESystem with proper SI units that can be directly discretized with MethodOfLines.jl. All variables and parameters carry SI unit annotations, and unit consistency is verified during system construction.\n\nusing ModelingToolkit: t\nusing DomainSets\nusing MethodOfLines\n\n# Create the Saint-Venant PDE system with 70 mm/hr rainfall on a 0.5 m domain\npde = SaintVenantPDE(0.5, 60.0;\n    P_val = 70.0 / 1000 / 3600,  # 70 mm/hr in m/s\n    S_0_val = 0.01,\n    n_manning_val = 0.03,\n    h_init_val = 1e-3,\n    q_init_val = 0.0)\n\n# Discretize using method of lines (finite differences)\nl = pde.ivs[2]\ndl = 0.1\ndiscretization = MOLFiniteDifference([l => dl], t, approx_order = 2)\nprob = discretize(pde, discretization; checks = false)\n\n# Solve the discretized ODE system\nsol = solve(prob)\n\nh_tilde = pde.dvs[1]\nq_flux = pde.dvs[2]\ndisc_l = sol[l]\nh_vals = sol[h_tilde]\n\n# Plot spatial profiles of water depth at different times\np6 = plot(xlabel=\"Distance along slope l (m)\",\n          ylabel=\"Flow depth hÌƒ (m)\",\n          title=\"Saint-Venant PDE: Water Depth Evolution (Eq. 1)\",\n          legend=:topleft)\n\nfor (i, ti) in enumerate(sol.t)\n    label_str = \"t = $(round(ti, digits=1)) s\"\n    plot!(p6, disc_l, h_vals[i, :], label=label_str, linewidth=2)\nend\n\np6\n\nprintln(\"ODEProblem created with $(length(prob.u0)) unknowns\")\nprintln(\"Time span: $(prob.tspan)\")\nprintln(\"Solution time steps: $(length(sol.t))\")","category":"section"},{"location":"surface_runoff/#Limitations","page":"Surface Runoff","title":"Limitations","text":"The current implementation provides:\n\nSingle-node ODE components (SurfaceRunoff, HeavisideBoundaryCondition) suitable for coupling with the EarthSciML framework\nPDE spatial solution (SaintVenantPDE) via MethodOfLines.jl discretization of the Saint-Venant equations (Eq. 1) with full SI unit support\n\nThe following features from Wang et al. (2020) are not yet implemented:\n\nRichards equation for subsurface flow (Eq. 2) â€” requires a separate subsurface flow component\nCoupled surface-subsurface simulations (Figs. 3-6) â€” requires both surface and subsurface models\nRidge-furrow water harvesting application (Figs. 7-8) â€” requires the full coupled model with complex topography","category":"section"},{"location":"surface_runoff/#EnvironmentalTransport.SurfaceRunoff","page":"Surface Runoff","title":"EnvironmentalTransport.SurfaceRunoff","text":"SurfaceRunoff(; name) -> ModelingToolkitBase.System\n\n\nCreate a surface runoff model based on the Saint-Venant equation system for surface water movement, following the approach of Wang et al. (2020).\n\nThe model describes mass conservation and momentum conservation of surface water flow along a soil surface slope. The Saint-Venant equations are:\n\nfracpartial tildehpartial t = -fracpartial qpartial l + (P - I)\n\nfracpartial qpartial t = -fracpartialpartial lleft(fracq^2tildeh + fracg tildeh^22right) + g tildeh (S_0 - S_f)\n\nwhere tildeh is the flow depth (ponded water height), q is the surface runoff flux per unit width, P is precipitation flux, I is infiltration flux, S_0 is the surface slope, and S_f is the friction slope computed from Manning's equation.\n\nThis component represents the equations at a single surface node. The spatial derivative terms (partial q  partial l and the momentum flux divergence) are represented as input parameters that should be provided by a spatial discretization scheme or coupled model.\n\nReference: Wang, Z., Timlin, D., Kouznetsov, M., Fleisher, D., Li, S., Tully, K., & Reddy, V. (2020). Coupled model of surface runoff and surface-subsurface water movement. Advances in Water Resources, 137, 103499. https://doi.org/10.1016/j.advwatres.2019.103499\n\n\n\n\n\n","category":"function"},{"location":"surface_runoff/#EnvironmentalTransport.HeavisideBoundaryCondition","page":"Surface Runoff","title":"EnvironmentalTransport.HeavisideBoundaryCondition","text":"HeavisideBoundaryCondition(\n;\n    name\n) -> ModelingToolkitBase.System\n\n\nCreate a smoothed Heaviside boundary condition component for coupling surface and subsurface water flow, following Wang et al. (2020).\n\nThe Heaviside step function determines whether the soil surface is in a ponding state (h â‰¥ 0) or unsaturated state (h < 0), enabling automatic switching between infiltration and evaporation boundary conditions:\n\neta_omega(h) = frac1pi arctanleft(frachomegaright) + frac12\n\ndelta_omega(h) = frac1pi fracomegaomega^2 + h^2\n\nThese smooth approximations converge to the Heaviside step function and Dirac delta function respectively as omega to 0^+.\n\nThe boundary condition equation is (Eq. 3):\n\nfracpartial(eta(h) cdot h)partial t - (P - I) = 0\n\nReference: Wang, Z., Timlin, D., Kouznetsov, M., Fleisher, D., Li, S., Tully, K., & Reddy, V. (2020). Coupled model of surface runoff and surface-subsurface water movement. Advances in Water Resources, 137, 103499. https://doi.org/10.1016/j.advwatres.2019.103499\n\n\n\n\n\n","category":"function"},{"location":"surface_runoff/#EnvironmentalTransport.SaintVenantPDE","page":"Surface Runoff","title":"EnvironmentalTransport.SaintVenantPDE","text":"SaintVenantPDE(\n    L_domain,\n    T_end;\n    P_val,\n    I_val,\n    S_0_val,\n    n_manning_val,\n    g_val,\n    h_min_val,\n    h_init_val,\n    q_init_val,\n    name\n) -> ModelingToolkitBase.PDESystem\n\n\nCreate a PDESystem for the Saint-Venant equations (Eq. 1 from Wang et al., 2020) suitable for spatial discretization with MethodOfLines.jl.\n\nThe system implements the full 1D Saint-Venant equations with proper SI units:\n\nMass conservation (Eq. 1a): partial tildehpartial t = -partial qpartial l + (P - I)\nMomentum conservation (Eq. 1b): partial qpartial t = -partial Fpartial l + g tildeh(S_0 - S_f)\nMomentum flux (auxiliary): F = q^2tildeh + g tildeh^22\n\nwhere S_f is Manning's friction slope computed with non-dimensionalized fractional exponents: S_f = ((nn_ref)(qq_ref))^2  (tildehh_ref)^103.\n\nArguments\n\nL_domain: Length of the spatial domain (m)\nT_end: Duration of the simulation (s)\n\nKeyword Arguments\n\nP_val: Precipitation rate (m/s), default 70 mm/hr\nI_val: Infiltration rate (m/s), default 0.0\nS_0_val: Surface slope (dimensionless), default 0.01\nn_manning_val: Manning roughness coefficient (m^(-1/3)Â·s), default 0.03\ng_val: Gravitational acceleration (m/sÂ²), default 9.81\nh_min_val: Minimum flow depth to prevent singularity (m), default 1e-5\nh_init_val: Initial and boundary flow depth (m), default 1e-3\nq_init_val: Initial and boundary flux (mÂ²/s), default 0.0\nname: System name, default :SaintVenantPDE\n\nReference: Wang, Z., Timlin, D., Kouznetsov, M., Fleisher, D., Li, S., Tully, K., & Reddy, V. (2020). Coupled model of surface runoff and surface-subsurface water movement. Advances in Water Resources, 137, 103499. https://doi.org/10.1016/j.advwatres.2019.103499\n\n\n\n\n\n","category":"function"},{"location":"puff-gauss-kc/#Puff-GaussianKC-Model","page":"Puff Gaussian KC","title":"Puff GaussianKC Model","text":"This document demonstrates the setup and execution of a Puff Model for simulating the trajectory and concentration of multiple puffs. The model computes how puffs disperse in the atmosphere over time. This example uses GaussianKC model that calculates the time evolution of horizontal puff dispersion (sigmax, sigmay) based on turbulent velocity fluctuations (Ïƒux, Ïƒuy). It also computes the ground-level centerline concentration (Cgl) per unit mass assuming a top-hat vertical distribution within the lowest layer. The concentration is evaluated only when the puff is within the surface layer (zagl â‰¤ Î”z); otherwise, it is set to zero. GaussianKC model must be coupled with BoundaryLayerMixingKC model that implements the Kantha-Clayson & Garratt turbulence parameterization for boundary layer mixing, as described in NOAA ARL-224 (https://www.arl.noaa.gov/documents/reports/arl-224.pdf) and HYSPLIT documentation.\n\nWe begin by importing the necessary libraries. \n\nusing Dates\nusing Plots\nusing Random\nusing EarthSciMLBase, EarthSciData, EnvironmentalTransport\nusing Aerosol\nusing ModelingToolkit, StochasticDiffEq\nusing ModelingToolkit: t\nusing EnvironmentalTransport: GaussianKC, PuffCoupler, GaussianKCCoupler, BoundaryLayerMixingKC, BoundaryLayerMixingKCCoupler\nnothing #hide","category":"section"},{"location":"puff-gauss-kc/#Reproducibility-Setup","page":"Puff Gaussian KC","title":"Reproducibility Setup","text":"Here we set a fixed seed (e.g., 1234) so the random turbulence is reproducible across different runs.\n\nRandom.seed!(1234)","category":"section"},{"location":"puff-gauss-kc/#Simulation-Parameters","page":"Puff Gaussian KC","title":"Simulation Parameters","text":"The following are key simulation parameters used to define the puff model and the scenario being simulated:\n\nstart: Defines the time when the event starts. simulationlength: Duration of the simulation (24 hours in this case). puffreleaseinterval: The time interval between each puff release (in seconds). puffreleaseperinterval: The number of puffs released per time interval. ec0: Initial mass of elemental carbon released in each interval.\n\nstart = DateTime(2019, 06, 15, 0, 0, 0)\nsimulationlength = 24 * 1\npuff_release_interval = 3600.0\npuff_release_per_interval = 5\nec_0 = 100.0\n\npuffs = [\n    (-120.6, 46.6, 3.0),\n    (-119.0, 47.0, 5.0),\n    (-121.0, 46.5, 4.0),\n    (-120.8, 46.8, 3.5),\n    (-120.4, 46.7, 6.0),\n    (-120.9, 46.6, 2.0),\n    (-119.5, 46.9, 3.0),\n    (-120.7, 47.2, 5.5),\n    (-120.2, 46.5, 4.0),\n    (-120.6, 46.3, 6.0)\n]\n\nÎ”Î»_deg = 0.3125\nÎ”Ï†_deg = 0.25\nÎ”Î» = deg2rad(Î”Î»_deg)\nÎ”Ï† = deg2rad(Î”Ï†_deg)","category":"section"},{"location":"puff-gauss-kc/#Domain-and-Model","page":"Puff Gaussian KC","title":"Domain and Model","text":"We define the simulation domain, including the range of longitudes, latitudes, and vertical levels. Then, we couple the models necessary for simulating particle dispersion and mixing, such as Puff, BoundaryLayerMixingKC, and GaussianKC.\n\nDomainInfo: Defines the spatial and temporal extent of the simulation, including longitude, latitude, and vertical levels.\n\ndomain = DomainInfo(\n    start, start + Hour(simulationlength);\n    lonrange = deg2rad(-130 - Î”Î»_deg):Î”Î»:deg2rad(-60 + Î”Î»_deg),\n    latrange = deg2rad(25 - Î”Ï†_deg):Î”Ï†:deg2rad(61 + Î”Ï†_deg),\n    levrange = 1:72\n)\n\nmodel = couple(\n    Puff(domain), \n    BoundaryLayerMixingKC(),            \n    GEOSFP(\"0.25x0.3125\", domain; stream = false),\n    ElementalCarbon(),\n    GaussianKC()\n)\n\nconst sys = convert(System, model)\nequations(sys)[1:5]","category":"section"},{"location":"puff-gauss-kc/#Solve-The-Model","page":"Puff Gaussian KC","title":"Solve The Model","text":"In this step, we solve the model once to ensure that all necessary data is properly loaded and that the system is initialized correctly. We define the initial conditions for key parameters, such as sigmax (horizontal dispersion in the x-direction), sigmay (horizontal dispersion in the y-direction), and turbulent velocity components (wprime, uprimex, uprimey). We then set up the SDEProblem (Stochastic Differential Equation Problem) to model the system stochastically. The SRIW1 solver is used to solve the system of equations, accounting for the random variability in the system's behavior over time. \n\ntspan = get_tspan(domain)\n\nu0 = [\n    sys.GaussianKCâ‚Šsigma_x => 0.00001,\n    sys.GaussianKCâ‚Šsigma_y => 0.00001,\n    sys.BoundaryLayerMixingKCâ‚Šwprime => 0.0,\n    sys.BoundaryLayerMixingKCâ‚Šuprime_x => 0.0,\n    sys.BoundaryLayerMixingKCâ‚Šuprime_y => 0.0,\n]\n\nprob = SDEProblem(sys, u0, tspan)\n\nsol = solve(prob, SRIW1(); dt = 60.0)","category":"section"},{"location":"puff-gauss-kc/#Define-Per-Puff-Problems","page":"Puff Gaussian KC","title":"Define Per-Puff Problems","text":"We define the function prob_func, which sets the initial conditions for each puff. The initial release time for each puff is calculated based on the index i of the puff, and the release interval.\n\n\nfunction prob_func(prob, i, repeat)\n    rlon = deg2rad(puffs[i][1])\n    rlat = deg2rad(puffs[i][2])\n    rlev = puffs[i][3]\n\n    u0 = [\n        sys.Puffâ‚Šlon => rlon,\n        sys.Puffâ‚Šlat => rlat,\n        sys.Puffâ‚Šlev => rlev,\n        sys.ElementalCarbonâ‚ŠEC => ec_0 / puff_release_per_interval,\n    ]\n\n    p = [\n        sys.GaussianKCâ‚ŠÎ”z => 100,\n    ]\n\n    ts = (tspan[1] + floor((i-1) / puff_release_per_interval) * puff_release_interval, tspan[2])\n    remake(prob; u0 = u0, p = p, tspan = ts)\nend\n","category":"section"},{"location":"puff-gauss-kc/#Solve-Each-Puff-and-Plot-Trajectories","page":"Puff Gaussian KC","title":"Solve Each Puff and Plot Trajectories","text":"We solve the problem for puffs and store the results. Then, we generate an animation of the puff trajectories on a 3D map to visualize their movement and dispersion over time.\n\nensemble_prob = EnsembleProblem(prob, prob_func = prob_func, safetycopy = false)\n\nesol = solve(ensemble_prob, SRIW1(), EnsembleThreads(); trajectories = length(puffs), dt = 60.0)\n\nvars = [sys.Puffâ‚Šlon, sys.Puffâ‚Šlat, sys.Puffâ‚Šlev]\nranges = [(Inf, -Inf), (Inf, -Inf), (Inf, -Inf)]\n\nfor sol in esol\n    for (i, var) in enumerate(vars)\n        if !isempty(sol)\n            data = sol[var]\n            current_min, current_max = ranges[i]\n            ranges[i] = (min(current_min, minimum(data)), max(current_max, maximum(data)))\n        end\n    end\nend\n\nt_ref = EarthSciMLBase.get_tref(domain)\nsim_end_time = start + Hour(simulationlength)\n\nanim = @animate for dt in datetime2unix(start):puff_release_interval:datetime2unix(sim_end_time)\n    t = dt - t_ref\n    \n    p = plot(\n        xlim = rad2deg.(ranges[1]), \n        ylim = rad2deg.(ranges[2]), \n        zlim = ranges[3],\n        title = \"Time: $(unix2datetime(dt))\",\n        xlabel = \"Longitude\", ylabel = \"Latitude\", zlabel = \"Level\",\n        camera = (30, 45)\n    )\n    \n    for sol in esol\n        if t < sol.t[1] || t > sol.t[end]\n            continue\n        end\n        \n        lon = rad2deg(sol(t, idxs=sys.Puffâ‚Šlon))\n        lat = rad2deg(sol(t, idxs=sys.Puffâ‚Šlat))\n        lev = sol(t, idxs=sys.Puffâ‚Šlev)\n        conc = sol(t, idxs=sys.GaussianKCâ‚ŠC_gl)\n        \n        marker_color = cgrad(:inferno)[min(1.0, log10(conc + 1e-9) / 5)] \n        \n        scatter!(p,\n            [lon], [lat], [lev],\n            label = :none, \n            markercolor = marker_color, \n            markersize = 5\n        )\n    end\nend\n\ngif(anim, \"puff_animation.gif\", fps = 5)","category":"section"},{"location":"puff-gauss-kc/#Plot-Ground-Level-Centerline-Concentration","page":"Puff Gaussian KC","title":"Plot Ground-Level Centerline Concentration","text":"Next we plot the Ground-Level Centerline Concentration for all simulated puffs. This represents the concentration of the pollutant at the surface (per unit mass) at the center of each puff derived from the Gaussian puff equations.\n\np_conc_0 = plot(\n    title = \"Ground-level centerline concentration\",\n    xlabel = \"Time\",\n    ylabel = \"Concentration (1/mÂ³)\",\n    legend = :outertopright,\n    xrotation = 45\n)\n\nfor (i, sol) in enumerate(esol)\n    time_vals = [start + Second(round(Int, t)) for t in sol.t]\n    c_gl_vals = sol[sys.GaussianKCâ‚ŠC_gl]\n    \n    plot!(p_conc_0, time_vals, c_gl_vals, \n          label = \"Puff $i\", lw = 2, alpha = 0.8)\nend\n\np_conc_0","category":"section"},{"location":"puff-gauss-kc/#Concentration-at-a-Receptor-Point","page":"Puff Gaussian KC","title":"Concentration at a Receptor Point","text":"In this section, we compute the concentration at a receptor location (e.g., lon = -120Â°, lat = 46.5Â°) by summing the contribution from all simulated puffs at each time step. For each puff, we evaluate an elliptical Gaussian kernel using the puffâ€™s horizontal spreads (Ïƒx, Ïƒy), its center position (lon, lat), and its ground-level centerline concentration (C_gl) per unit mass. Finally, we plot concentration versus time.\n\nreceptor_lon_deg = -120.0\nreceptor_lat_deg = 46.5\nÎ»r = deg2rad(receptor_lon_deg)\nÏ†r = deg2rad(receptor_lat_deg)\n\nR_earth = 6.371e6 # Earth radius (m) for local tangent-plane distance approximation\n\n# dx ~ east-west distance, dy ~ north-south distance\ndxdy_m(lon_puff, lat_puff, lon_rec, lat_rec) = begin\n    dx = R_earth * cos(0.5*(lat_puff + lat_rec)) * (lon_rec - lon_puff)\n    dy = R_earth * (lat_rec - lat_puff)\n    dx, dy\nend\n\n# Build a time grid for plotting (e.g., every 1 hour)\nsim_end_time = start + Hour(simulationlength)\ntgrid_unix = collect(datetime2unix(start):3600.0:datetime2unix(sim_end_time))\ntgrid = tgrid_unix .- t_ref\ntime_dt = unix2datetime.(tgrid_unix)\n\nC_rec = zeros(length(tgrid)) # Total concentration at receptor\n\nfor (k, tsec) in enumerate(tgrid)\n    csum = 0.0\n    for sol in esol\n        if isempty(sol) || tsec < sol.t[1] || tsec > sol.t[end]\n            continue\n        end\n\n        # Puff center location\n        lonp = sol(tsec, idxs = sys.Puffâ‚Šlon)\n        latp = sol(tsec, idxs = sys.Puffâ‚Šlat)\n\n        # GaussianKC horizontal dispersion std dev\n        sx = sol(tsec, idxs = sys.GaussianKCâ‚Šsigma_x)\n        sy = sol(tsec, idxs = sys.GaussianKCâ‚Šsigma_y)\n\n        # Centerline ground-level concentration per unit mass (1/m^3)\n        Cgl = sol(tsec, idxs = sys.GaussianKCâ‚ŠC_gl)\n\n        # Mass of elemental carbon in the Puffs\n        m = sol(tsec, idxs = sys.ElementalCarbonâ‚ŠEC)\n\n        dx, dy = dxdy_m(lonp, latp, Î»r, Ï†r)\n        kernel = exp(-0.5 * ((dx / sx)^2 + (dy / sy)^2))\n\n        csum += m * Cgl * kernel\n    end\n    C_rec[k] = csum\nend\n\n# Convert to Âµg/m^3\nC_rec_ugm3 = C_rec .* 1e9\n\np_conc = plot(\n    time_dt, C_rec_ugm3;\n    title  = \"Concentration at receptor (lon=$(receptor_lon_deg), lat=$(receptor_lat_deg))\",\n    xlabel = \"Time\",\n    ylabel = \"Concentration (Âµg/mÂ³)\",\n    lw = 2,\n    legend = false,\n    xrotation = 45\n)\n\np_conc\n","category":"section"},{"location":"puff-gauss-kc/#Animated-Spatial-Heatmap","page":"Puff Gaussian KC","title":"Animated Spatial Heatmap","text":"Here we compute concentration on a 2D longitudeâ€“latitude grid at each time step using the same Gaussian kernel method as the single-receptor calculation above, then animate the result as a heatmap.\n\n# Define spatial grid\nlon_range = range(-122.0, -118.0; length=50)\nlat_range = range(45.5, 48.0; length=50)\n\nanim_heatmap = @animate for (k, tsec) in enumerate(tgrid)\n    C_grid = zeros(length(lat_range), length(lon_range))\n\n    for (j, lon_deg) in enumerate(lon_range)\n        for (i, lat_deg) in enumerate(lat_range)\n            Î»_rec = deg2rad(lon_deg)\n            Ï†_rec = deg2rad(lat_deg)\n            csum = 0.0\n            for sol in esol\n                if isempty(sol) || tsec < sol.t[1] || tsec > sol.t[end]\n                    continue\n                end\n                lonp = sol(tsec, idxs = sys.Puffâ‚Šlon)\n                latp = sol(tsec, idxs = sys.Puffâ‚Šlat)\n                sx   = sol(tsec, idxs = sys.GaussianKCâ‚Šsigma_x)\n                sy   = sol(tsec, idxs = sys.GaussianKCâ‚Šsigma_y)\n                Cgl  = sol(tsec, idxs = sys.GaussianKCâ‚ŠC_gl)\n                m    = sol(tsec, idxs = sys.ElementalCarbonâ‚ŠEC)\n\n                dx, dy = dxdy_m(lonp, latp, Î»_rec, Ï†_rec)\n                kernel = exp(-0.5 * ((dx / sx)^2 + (dy / sy)^2))\n                csum += m * Cgl * kernel\n            end\n            C_grid[i, j] = csum * 1e9  # Âµg/mÂ³\n        end\n    end\n\n    heatmap(\n        collect(lon_range), collect(lat_range), C_grid;\n        title  = \"Concentration at $(time_dt[k])\",\n        xlabel = \"Longitude (Â°)\",\n        ylabel = \"Latitude (Â°)\",\n        colorbar_title = \"Concentration (Âµg/mÂ³)\",\n        clims  = (0, maximum(C_rec_ugm3)),\n        color  = :inferno\n    )\nend\n\ngif(anim_heatmap, \"puff_heatmap.gif\", fps = 3)","category":"section"},{"location":"#EnvironmentalTransport:-Algorithms-for-Environmental-Mass-Transport","page":"Home","title":"EnvironmentalTransport: Algorithms for Environmental Mass Transport","text":"Documentation for EnvironmentalTransport.jl.\n\nThis package contains algorithms for simulating environmental mass transport, for use with the EarthSciML ecosystem.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"EnvironmentalTransport\")","category":"section"},{"location":"#Feature-Summary","page":"Home","title":"Feature Summary","text":"This package contains types and functions designed to simplify the process of constructing and composing symbolically-defined Earth Science model components together.","category":"section"},{"location":"#Feature-List","page":"Home","title":"Feature List","text":"Numerical Advection\nGeneral Circulation (Coriolis parameter, geostrophic wind, thermal wind)","category":"section"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"Please refer to the SciML ColPrac: Contributor's Guide on Collaborative Practices for Community Packages for guidance on PRs, issues, and other matters relating to contributing.","category":"section"},{"location":"#Reproducibility","page":"Home","title":"Reproducibility","text":"<details><summary>The documentation of this EnvironmentalTransport package was built using these direct dependencies,</summary>\n\nusing Pkg # hide\nPkg.status() # hide\n\n</details>\n\n<details><summary>and using this machine and Julia version.</summary>\n\nusing InteractiveUtils # hide\nversioninfo() # hide\n\n</details>\n\n<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>\n\nusing Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide\n\n</details>\n\nYou can also download the \n<a href=\"\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Manifest.toml\")\n\n\">manifest</a> file and the\n<a href=\"\n\nusing TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink = Markdown.MD(\"https://github.com/EarthSciML/\"*name*\".jl/tree/gh-pages/v\"*version*\"/assets/Project.toml\")\n\n\">project</a> file.","category":"section"},{"location":"advection/#Numerical-Advection-Operator","page":"Advection","title":"Numerical Advection Operator","text":"We have two ways to represent phenomena that occur across space such as advection: through symbolically-defined partial differential equation systems, which will be covered elsewhere in documentation, and through numerically-implemented algorithms. This is an example of the latter. (Currently, symbolically defined PDEs are too slow to be used in large-scale simulations.)\n\nTo demonstrate how it works, let's first set up our environment:\n\nusing EnvironmentalTransport\nusing EarthSciMLBase, EarthSciData\nusing ModelingToolkit, OrdinaryDiffEqDefault\nusing OrdinaryDiffEqTsit5: Tsit5\nusing OrdinaryDiffEqSSPRK: SSPRK22\nusing ProgressLogging\nusing ModelingToolkit: t, D\nusing DynamicQuantities\nusing Distributions, LinearAlgebra\nusing Dates\nusing NCDatasets, Plots\nnothing #hide","category":"section"},{"location":"advection/#Emissions","page":"Advection","title":"Emissions","text":"Next, let's set up an emissions scenario to advect. We'll make the emissions start at the beginning of the simulation and then taper off:\n\nusing EarthSciMLBase: CoupleType\n\nstarttime = DateTime(2022, 5, 1)\nendtime = DateTime(2022, 5, 2)\n\nstruct EmissionsCoupler\n    sys\nend\nfunction emissions(Î¼_lon, Î¼_lat, Ïƒ)\n    @parameters(lon=-97.0, [unit=u\"rad\"],\n        lat=30.0, [unit=u\"rad\"],\n        lev=1.0,)\n    @variables c(t) = 0.0 [unit=u\"kg\"]\n    @constants v_emis = 50.0 [unit=u\"kg/s\"]\n    @constants t_unit = 1.0 [unit=u\"s\"] # Needed so that arguments to `pdf` are unitless.\n    @constants t_ref = datetime2unix(starttime) [unit=u\"s\"]\n    dist = MvNormal([datetime2unix(starttime), Î¼_lon, Î¼_lat, 1],\n        Diagonal(map(abs2, [3600.0*24*3, Ïƒ, Ïƒ, 1])))\n    System([D(c) ~ pdf(dist, [t/t_unit, lon, lat, lev]) * v_emis],\n        t, name = :emissions, metadata = Dict(CoupleType => EmissionsCoupler))\nend\nfunction EarthSciMLBase.couple2(e::EmissionsCoupler, g::EarthSciData.GEOSFPCoupler)\n    e, g = e.sys, g.sys\n    e = param_to_var(e, :lat, :lon, :lev)\n    ConnectorSystem([e.lat ~ g.lat, e.lon ~ g.lon, e.lev ~ g.lev], e, g)\nend\n\nemis = emissions(deg2rad(-97.0), deg2rad(40.0), deg2rad(1))","category":"section"},{"location":"advection/#Coupled-System","page":"Advection","title":"Coupled System","text":"Next, let's set up a spatial and temporal domain for our simulation, and some input data from GEOS-FP to get wind fields for our advection. We need to use coord_defaults in this case to get the GEOS-FP data to work correctly, but it doesn't matter what the defaults are. We also set up an outputter to save the results of our simulation, and couple the components we've created so far into a single system.\n\n\ndomain = DomainInfo(\n    starttime, endtime;\n    lonrange = deg2rad(-115):deg2rad(1):deg2rad(-68.75),\n    latrange = deg2rad(25):deg2rad(1):deg2rad(53.7),\n    levrange = 1:1:15)\n\ngeosfp = GEOSFP(\"4x5\", domain)\ngeosfp = EarthSciMLBase.copy_with_change(geosfp, discrete_events = []) # Workaround for bug.\n\noutfile = (\"RUNNER_TEMP\" âˆˆ keys(ENV) ? ENV[\"RUNNER_TEMP\"] : tempname()) * \"out.nc\" # This is just a location to save the output.\noutput = NetCDFOutputter(outfile, 3600.0)\n\ncsys = couple(emis, domain, geosfp, output)","category":"section"},{"location":"advection/#Advection-Operator","page":"Advection","title":"Advection Operator","text":"Next, we create an AdvectionOperator to perform advection. We need to specify a time step (300 s in this case), as stencil algorithm to do the advection (current options are upwind1_stencil). We also specify zero gradient boundary conditions.\n\nThen, we couple the advection operator to the rest of the system.\n\nadv = AdvectionOperator(300.0, upwind1_stencil, ZeroGradBC())\n\ncsys = couple(csys, adv)\n\nNow, we initialize a ODEProblem to run our demonstration. We use the Tsit5 time integrator for our emissions system of equations, and a time integration scheme for our advection operator (SSPRK22 in this case). Refer here for the available time integrator choices. We also choose a operator splitting interval of 300 seconds. Then, we run the simulation.\n\nst = SolverStrangSerial(Tsit5(), 300.0)\nprob = ODEProblem(csys, st)\n\n@time solve(\n    prob, SSPRK22(), dt = 300, save_on = false, save_start = false, save_end = false,\n    initialize_save = false, progress = true, progress_steps = 1)","category":"section"},{"location":"advection/#Visualization","page":"Advection","title":"Visualization","text":"Finally, we can visualize the results of our simulation:\n\nds = NCDataset(outfile, \"r\")\n\nimax = argmax(reshape(maximum(ds[\"emissionsâ‚Šc\"][:, :, :, :], dims = (1, 3, 4)), :))\ngrid = EarthSciMLBase.grid(domain)\nanim = @animate for i in 1:size(ds[\"emissionsâ‚Šc\"])[4]\n    plot(\n        heatmap(rad2deg.(grid[1]), rad2deg.(grid[2]),\n            ds[\"emissionsâ‚Šc\"][:, :, 1, i]', title = \"Ground-Level\", xlabel = \"Longitude\", ylabel = \"Latitude\"),\n        heatmap(rad2deg.(grid[1]), grid[3], ds[\"emissionsâ‚Šc\"][:, imax, :, i]',\n            title = \"Vertical Cross-Section (lat=$(round(rad2deg(grid[2][imax]), digits=1)))\",\n            xlabel = \"Longitude\", ylabel = \"Vertical Level\"),\n        size = (1200, 400)\n    )\nend\ngif(anim, fps = 15)","category":"section"}]
}
